<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pokémon Battle Simulator — Browser Edition</title>
<style>
  :root{
    --bg:#0b1020; --card:#0f1724; --accent:#ffcc00; --muted:#9aa9c7;
    --hp-good:#48c774; --hp-mid:#ffd166; --hp-low:#f0433a;
  }
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(180deg,#07102b, #071733); color:#e6eef8; margin:0; padding:18px;}
  h1{margin:0 0 12px; font-size:20px; color:var(--accent)}
  .wrap{display:grid; grid-template-columns: 360px 1fr; gap:16px; align-items:start;}
  .panel{background:var(--card); border-radius:12px; padding:12px; box-shadow:0 6px 18px rgba(0,0,0,0.6);}
  .team-builder{display:grid; gap:8px;}
  .slot{display:flex; gap:8px; align-items:center; background:rgba(255,255,255,0.02); padding:8px; border-radius:8px;}
  .slot img{width:68px; height:68px; image-rendering:pixelated; background:#0b1220; border-radius:6px; object-fit:contain;}
  .slot .meta{flex:1}
  .slot input[type="text"]{width:100%; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.05); background:transparent; color:#e6eef8}
  .tiny{font-size:12px;color:var(--muted)}
  button, select{cursor:pointer}
  .btn{background:linear-gradient(90deg,#16324a,#1e4a6b); color:#e6eef8; border:none; padding:8px 10px; border-radius:8px; font-weight:600}
  .team-actions{display:flex; gap:8px; margin-top:8px}
  .battle-area{display:grid; grid-template-rows:auto 1fr; gap:12px}
  .field{display:flex; gap:12px; align-items:center; justify-content:space-between;}
  .poke-card{width:48%; background:linear-gradient(180deg,#0d2233,#071526); padding:10px; border-radius:10px; display:flex; gap:10px; align-items:center;}
  .poke-card.right{flex-direction:row-reverse; text-align:right}
  .hpbar{height:14px; background:rgba(255,255,255,0.06); border-radius:999px; overflow:hidden; margin-top:6px}
  .hpfill{height:100%; width:100%; background:var(--hp-good); transition:width 400ms linear}
  .moves{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px}
  .movebtn{flex:1; min-width:110px; background:linear-gradient(90deg,#0b2b3f,#06405b); border-radius:8px; padding:8px; border:1px solid rgba(255,255,255,0.03); color:#e6eef8}
  .statusline{font-size:13px; color:var(--muted); margin-top:6px}
  .center{display:flex; gap:8px; align-items:center; justify-content:center}
  .log{height:180px; overflow:auto; background:linear-gradient(180deg,#071126,#08142a); padding:8px; border-radius:8px; font-size:13px}
  label.inline{display:flex; gap:6px; align-items:center}
  .moves-chooser{display:flex; gap:8px; flex-direction:column; margin-top:6px}
  .move-select{width:100%; padding:6px; border-radius:6px; background:transparent; color:#e6eef8;border:1px solid rgba(255,255,255,0.04)}
  .small{font-size:12px}
  .muted{color:var(--muted)}
  footer{margin-top:12px; font-size:12px; color:var(--muted)}
</style>
</head>
<body>
  <h1>Pokémon Battle Simulator — Browser Edition</h1>
  <div class="wrap">
    <div class="panel">
      <div class="team-builder">
        <div style="display:flex; justify-content:space-between; align-items:center">
          <div><strong>Team A (left)</strong> <span class="tiny">— build 6</span></div>
          <div class="tiny">Level fixed at 50</div>
        </div>
        <div id="teamA" class="team-list"></div>

        <hr style="border:none; height:1px; background:rgba(255,255,255,0.03); margin:8px 0">

        <div style="display:flex; justify-content:space-between; align-items:center">
          <div><strong>Team B (right)</strong> <span class="tiny">— build 6</span></div>
          <div class="tiny">Player controls both sides possible</div>
        </div>
        <div id="teamB" class="team-list"></div>

        <div class="team-actions">
          <button id="resetTeams" class="btn">Reset teams</button>
          <button id="startBattle" class="btn">Start battle</button>
        </div>

        <div style="margin-top:8px" class="tiny muted">
          How to add: type a Pokémon name or ID (e.g., "pikachu" or "25") into a slot and press Enter or the load button. Then choose up to 4 moves per Pokémon from the dropdowns.
        </div>
      </div>
    </div>

    <div class="panel battle-area">
      <div style="display:flex; justify-content:space-between; align-items:center">
        <div><strong>Battle Field</strong></div>
        <div class="tiny muted">PokeAPI: data and sprites live from pokeapi.co.</div>
      </div>

      <div class="field">
        <div class="poke-card" id="leftCard">
          <div style="width:90px; text-align:center;">
            <img id="leftSprite" src="" alt="" />
          </div>
          <div style="flex:1">
            <div id="leftName"><strong>—</strong></div>
            <div class="statusline" id="leftStats">HP: — | Atk: —</div>
            <div class="hpbar"><div id="leftHpFill" class="hpfill" style="width:0%"></div></div>
            <div class="moves" id="leftMoves"></div>
            <div style="margin-top:6px">
              <label class="inline"><input id="leftAuto" type="checkbox"> Auto-move</label>
            </div>
          </div>
        </div>

        <div class="poke-card right" id="rightCard">
          <div style="width:90px; text-align:center;">
            <img id="rightSprite" src="" alt="" />
          </div>
          <div style="flex:1">
            <div id="rightName"><strong>—</strong></div>
            <div class="statusline" id="rightStats">HP: — | Atk: —</div>
            <div class="hpbar"><div id="rightHpFill" class="hpfill" style="width:0%"></div></div>
            <div class="moves" id="rightMoves"></div>
            <div style="margin-top:6px">
              <label class="inline"><input id="rightAuto" type="checkbox"> Auto-move</label>
            </div>
          </div>
        </div>
      </div>

      <div style="display:grid; grid-template-columns:1fr 200px; gap:12px; align-items:start;">
        <div>
          <div style="display:flex; gap:8px; align-items:center; margin-bottom:6px;">
            <button id="chooseMoveA" class="btn">Lock move (Left)</button>
            <button id="chooseMoveB" class="btn">Lock move (Right)</button>
            <button id="resolveTurn" class="btn">Resolve Turn</button>
          </div>
          <div class="log" id="log"></div>
        </div>

        <div>
          <div style="display:flex; flex-direction:column; gap:8px;">
            <div>
              <strong>Controls</strong>
              <div class="tiny muted">Pick moves for both sides manually or toggle Auto for a side.</div>
            </div>
            <div>
              <button id="swapSides" class="btn">Swap active Pokémon</button>
            </div>
            <div>
              <button id="resetBattle" class="btn">Reset Battle</button>
            </div>
          </div>
        </div>
      </div>

      <footer>
        Built with the PokéAPI (https://pokeapi.co) — uses live endpoints for pokemon, moves and types. If a sprite or data fails to load, check network or run local server. :contentReference[oaicite:1]{index=1}
      </footer>
    </div>
  </div>

<script>
/*
  POKÉ BATTLE SIM
  - Level fixed at 50
  - Uses PokeAPI v2 (https://pokeapi.co)
  - Damage formula simplified from main games:
      damage = floor((((2*L/5+2) * power * (A/D)) / 50) + 2) * modifier
    where modifier = STAB * typeEffectiveness * randomFactor(0.85-1.0)
  - Uses move.damage_class to pick physical vs special
  - Type effectiveness pulled from type endpoint damage_relations
  - Both players select a move, then moves resolve in order of speed
*/

const API_BASE = 'https://pokeapi.co/api/v2';
const LEVEL = 50;

function $id(id){return document.getElementById(id)}

// Simple helpers
function log(msg){
  const el = $id('log');
  const p = document.createElement('div');
  p.innerHTML = msg;
  el.prepend(p);
}

// Teams: each is array of 6 slots (null or Pokemon object)
let teamA = Array(6).fill(null);
let teamB = Array(6).fill(null);

// Battle state
let battle = {
  activeA: 0,
  activeB: 0,
  selectedMoveA: null,
  selectedMoveB: null,
  resolved: false,
  running: false
};

// Caches
const cache = {
  pokemon: new Map(),
  move: new Map(),
  type: new Map()
};

// --- API fetch helpers
async function fetchJSON(url){
  const res = await fetch(url);
  if(!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
  return res.json();
}

async function getPokemon(nameOrId){
  if(cache.pokemon.has(nameOrId)) return cache.pokemon.get(nameOrId);
  const data = await fetchJSON(`${API_BASE}/pokemon/${nameOrId.toString().toLowerCase()}`);
  // Simplify into a compact object
  const poke = {
    id: data.id,
    name: data.name,
    sprites: data.sprites,
    types: data.types.map(t=>t.type.name),
    stats: Object.fromEntries(data.stats.map(s => [s.stat.name, s.base_stat])),
    moves: data.moves.map(m => ({name: m.move.name, url: m.move.url}))
  };
  cache.pokemon.set(poke.name, poke);
  cache.pokemon.set(poke.id, poke);
  return poke;
}

async function getMove(urlOrName){
  if(cache.move.has(urlOrName)) return cache.move.get(urlOrName);
  let data;
  if(urlOrName.startsWith('http')) data = await fetchJSON(urlOrName);
  else data = await fetchJSON(`${API_BASE}/move/${urlOrName}`);
  const move = {
    id: data.id,
    name: data.name,
    power: data.power, // might be null for status moves
    accuracy: data.accuracy,
    pp: data.pp,
    type: data.type.name,
    damage_class: data.damage_class.name, // 'physical' | 'special' | 'status'
    priority: data.priority
  };
  cache.move.set(move.name, move);
  cache.move.set(move.id, move);
  return move;
}

async function getType(typeName){
  if(cache.type.has(typeName)) return cache.type.get(typeName);
  const data = await fetchJSON(`${API_BASE}/type/${typeName}`);
  cache.type.set(typeName, data);
  return data;
}

// --- UI helpers to build team slot elements
function createTeamSlot(side, index){
  const slot = document.createElement('div');
  slot.className = 'slot';
  slot.innerHTML = `
    <img id="${side}-img-${index}" src="" alt="">
    <div class="meta">
      <div style="display:flex;gap:8px">
        <input id="${side}-input-${index}" placeholder="name or id" />
        <button id="${side}-load-${index}" class="btn small">Load</button>
      </div>
      <div class="moves-chooser" id="${side}-moves-${index}"></div>
    </div>
  `;
  return slot;
}

function renderTeams(){
  const elA = $id('teamA'); elA.innerHTML='';
  const elB = $id('teamB'); elB.innerHTML='';
  for(let i=0;i<6;i++){
    elA.appendChild(createTeamSlot('A', i));
    elB.appendChild(createTeamSlot('B', i));
  }
  // attach listeners for load buttons and inputs
  for(let i=0;i<6;i++){
    setupSlotControls('A', i);
    setupSlotControls('B', i);
  }
}

function setupSlotControls(side, index){
  const input = $id(`${side}-input-${index}`);
  const loadBtn = $id(`${side}-load-${index}`);
  loadBtn.onclick = async ()=>{
    const val = input.value.trim();
    if(!val){ alert('Type a pokemon name or id into the box.'); return; }
    try{
      const poke = await getPokemon(val);
      const slotObj = {
        base: poke,
        name: poke.name,
        level: LEVEL,
        maxHp: calcHP(poke.stats['hp'], LEVEL),
        curHp: calcHP(poke.stats['hp'], LEVEL),
        stats: {
          atk: poke.stats['attack'],
          def: poke.stats['defense'],
          spatk: poke.stats['special-attack'],
          spdef: poke.stats['special-defense'],
          speed: poke.stats['speed']
        },
        moves: [] // will store move objects (max 4)
      };
      if(side === 'A') teamA[index] = slotObj; else teamB[index] = slotObj;
      renderSlot(side, index);
    }catch(err){
      alert('Could not load Pokémon: ' + err.message);
    }
  };
  input.addEventListener('keyup', (e)=>{ if(e.key === 'Enter') loadBtn.click() });
}

function renderSlot(side, index){
  const slotData = (side==='A') ? teamA[index] : teamB[index];
  const img = $id(`${side}-img-${index}`);
  const movesDiv = $id(`${side}-moves-${index}`);
  movesDiv.innerHTML = '';
  if(!slotData){
    img.src = '';
    return;
  }
  img.src = slotData.base.sprites.front_default || '';
  // display 4 move dropdowns to pick moves (initialized with list of moves)
  for(let m=0;m<4;m++){
    const sel = document.createElement('select');
    sel.className = 'move-select';
    sel.innerHTML = `<option value="">-- choose move #${m+1 || ''} --</option>`;
    // add options (we will only use move name/url)
    // keep short list to moves that have a move object (we'll fetch metadata only on choose)
    for(const mv of slotData.base.moves){
      const opt = document.createElement('option');
      opt.value = mv.url; // use URL as identifier
      opt.textContent = mv.name;
      sel.appendChild(opt);
    }
    sel.onchange = async (e)=>{
      const url = e.target.value;
      if(!url) {
        slotData.moves[m] = null;
        return;
      }
      try{
        const mov = await getMove(url);
        slotData.moves[m] = mov;
        log(`${slotData.name} learned <strong>${mov.name}</strong> (power: ${mov.power ?? '—'}, type: ${mov.type}, ${mov.damage_class})`);
        renderSlot(side, index); // re-render to show perhaps updated state
      }catch(err){
        alert('Could not load move: ' + err.message);
      }
    };
    // preselect if exists
    if(slotData.moves[m]) sel.value = slotData.moves[m].url || slotData.moves[m].name || '';
    movesDiv.appendChild(sel);
  }
}

// --- Stat / HP formula helpers (simple)
function calcHP(baseHp, level){
  // simplified: HP = floor(((2*base + 31 + (252/4)) * L)/100) + L + 10
  // to keep simple, do: HP = baseHp*2 + level + 10 (scaled) -> but we'll use near-realistic:
  return Math.floor(((2 * baseHp) * level) / 100) + level + 10;
}

// Damage calculation
async function computeDamage(attacker, defender, move){
  if(!move || !move.power) return 0;
  // determine if physical or special
  const atkStat = (move.damage_class === 'physical') ? attacker.stats.atk : attacker.stats.spatk;
  const defStat = (move.damage_class === 'physical') ? defender.stats.def : defender.stats.spdef;
  const power = move.power;

  // base damage
  const base = Math.floor((((2*LEVEL/5 + 2) * power * (atkStat / Math.max(1,defStat))) / 50) + 2);

  // STAB
  const stab = attacker.base.types.includes(move.type) ? 1.5 : 1.0;

  // Type effectiveness: multiple types multiply
  let typeEff = 1.0;
  try{
    const typeData = await getType(move.type);
    // typeData.damage_relations.double_damage_to is "move type -> does double to these types"
    // But we need defender's types: check if move type is effective vs defender
    for(const t of defender.base.types){
      // if defender type is in no_damage_to => 0, half => 0.5, double => 2
      const rel = typeData.damage_relations;
      if(rel.no_damage_to.some(x=>x.name===t)) { typeEff *= 0.0; }
      else if(rel.half_damage_to.some(x=>x.name===t)) { typeEff *= 0.5; }
      else if(rel.double_damage_to.some(x=>x.name===t)) { typeEff *= 2.0; }
    }
  }catch(err){
    console.warn('Type fetch failed', err);
  }

  // random factor
  const rnd = (Math.random() * (1.0 - 0.85)) + 0.85;

  let modifier = stab * typeEff * rnd;
  const damage = Math.max(1, Math.floor(base * modifier));
  return {damage, modifier, stab, typeEff};
}

// --- Render active Pokémon in battle panel
function renderActive(){
  const left = teamA[battle.activeA];
  const right = teamB[battle.activeB];

  // Left
  if(left){
    $id('leftSprite').src = left.base.sprites.front_default || '';
    $id('leftName').innerHTML = `<strong>${left.name} (Lv ${left.level})</strong>`;
    $id('leftStats').textContent = `HP: ${left.curHp}/${left.maxHp} | Atk: ${left.stats.atk} Atk | SpA: ${left.stats.spatk} SpA | Spd: ${left.stats.speed} Spd`;
    const pct = Math.max(0, Math.floor((left.curHp / left.maxHp)*100));
    $id('leftHpFill').style.width = pct + '%';
    if(pct>45) $id('leftHpFill').style.background = 'var(--hp-good)';
    else if(pct>15) $id('leftHpFill').style.background = 'var(--hp-mid)';
    else $id('leftHpFill').style.background = 'var(--hp-low)';
    renderMoveButtons('left', left, 'A');
  } else {
    $id('leftSprite').src='';
    $id('leftName').innerHTML = `<strong>—</strong>`;
    $id('leftStats').textContent = '—';
    $id('leftMoves').innerHTML='';
  }

  // Right
  if(right){
    $id('rightSprite').src = right.base.sprites.front_default || right.base.sprites.back_default || '';
    $id('rightName').innerHTML = `<strong>${right.name} (Lv ${right.level})</strong>`;
    $id('rightStats').textContent = `HP: ${right.curHp}/${right.maxHp} | Atk: ${right.stats.atk} Atk | SpA: ${right.stats.spatk} SpA | Spd: ${right.stats.speed} Spd`;
    const pct = Math.max(0, Math.floor((right.curHp / right.maxHp)*100));
    $id('rightHpFill').style.width = pct + '%';
    if(pct>45) $id('rightHpFill').style.background = 'var(--hp-good)';
    else if(pct>15) $id('rightHpFill').style.background = 'var(--hp-mid)';
    else $id('rightHpFill').style.background = 'var(--hp-low)';
    renderMoveButtons('right', right, 'B');
  } else {
    $id('rightSprite').src='';
    $id('rightName').innerHTML = `<strong>—</strong>`;
    $id('rightStats').textContent = '—';
    $id('rightMoves').innerHTML='';
  }
}

function renderMoveButtons(panel, pocket, teamLetter){
  const container = $id(panel + 'Moves');
  container.innerHTML = '';
  if(!pocket) return;
  // create 4 move buttons; if an entry is null, show disabled placeholder
  for(let i=0;i<4;i++){
    const mv = pocket.moves[i];
    const btn = document.createElement('button');
    btn.className = 'movebtn';
    btn.disabled = !mv;
    if(!mv) { btn.textContent = `--`; container.appendChild(btn); continue; }
    btn.innerHTML = `${mv.name} ${mv.power ? '('+mv.power+')' : '(—)'}<div style="font-size:11px;color:var(--muted)"> ${mv.type} ${mv.damage_class}</div>`;
    btn.onclick = ()=>{
      // lock selection into battle
      if(teamLetter === 'A') battle.selectedMoveA = {pokemonIndex: battle.activeA, move: mv};
      else battle.selectedMoveB = {pokemonIndex: battle.activeB, move: mv};
      log(`${(teamLetter==='A') ? 'Left' : 'Right'} locked move <strong>${mv.name}</strong>`);
    };
    container.appendChild(btn);
  }
  // if auto checked, auto-pick
  if(panel === 'left' && $id('leftAuto').checked){
    autoPickMoveFor('A');
  }
  if(panel === 'right' && $id('rightAuto').checked){
    autoPickMoveFor('B');
  }
}

function autoPickMoveFor(teamLetter){
  const team = (teamLetter==='A') ? teamA : teamB;
  const idx = (teamLetter==='A') ? battle.activeA : battle.activeB;
  const pokemon = team[idx];
  if(!pokemon) return;
  // pick highest power move (non-null)
  let best = null;
  for(const m of pokemon.moves) if(m && m.power && (!best || (m.power > best.power))) best = m;
  if(!best) {
    // fallback: first non-null
    for(const m of pokemon.moves) if(m) { best = m; break; }
  }
  if(teamLetter==='A') battle.selectedMoveA = {pokemonIndex: idx, move: best};
  else battle.selectedMoveB = {pokemonIndex: idx, move: best};
  log(`${(teamLetter==='A') ? 'Left' : 'Right'} (auto) chose <strong>${best ? best.name : 'Struggle'}</strong>`);
}

// Resolve turn: both moves must be selected or auto-picked if auto-on
async function resolveTurn(){
  // auto-pick if checkbox on and no selection
  if($id('leftAuto').checked && !battle.selectedMoveA) autoPickMoveFor('A');
  if($id('rightAuto').checked && !battle.selectedMoveB) autoPickMoveFor('B');

  // ensure moves exist (allow null => struggle)
  const leftPick = battle.selectedMoveA;
  const rightPick = battle.selectedMoveB;

  // If none selected, do nothing
  if(!leftPick && !rightPick){
    alert('No moves selected for either side. Choose moves or enable Auto.');
    return;
  }

  // Determine order by speed and priority (priority not currently used beyond move.priority)
  const leftPokemon = teamA[battle.activeA];
  const rightPokemon = teamB[battle.activeB];
  if(!leftPokemon || !rightPokemon){ alert('Missing active Pokémon for a side'); return; }

  // Build actions
  const actionA = leftPick ? {side:'A', actor:leftPokemon, move:leftPick.move} : {side:'A', actor:leftPokemon, move:null};
  const actionB = rightPick ? {side:'B', actor:rightPokemon, move:rightPick.move} : {side:'B', actor:rightPokemon, move:null};

  // decide order: compare speed; tie -> random
  let first = actionA, second = actionB;
  if(rightPokemon.stats.speed > leftPokemon.stats.speed) { first = actionB; second = actionA; }
  else if(rightPokemon.stats.speed === leftPokemon.stats.speed && Math.random() > 0.5) { first = actionB; second = actionA; }

  // Apply first
  await applyAction(first, (first.side==='A') ? teamB[battle.activeB] : teamA[battle.activeA]);
  // check faint
  if(teamA[battle.activeA].curHp <= 0 || teamB[battle.activeB].curHp <= 0){
    concludeAfterTurn();
    // clear selected moves for next turn
    battle.selectedMoveA = null; battle.selectedMoveB = null;
    renderActive();
    return;
  }
  // Apply second
  await applyAction(second, (second.side==='A') ? teamB[battle.activeB] : teamA[battle.activeA]);

  concludeAfterTurn();
  battle.selectedMoveA = null; battle.selectedMoveB = null;
  renderActive();
}

// applyAction: actor uses move on target (target is object)
async function applyAction(action, target){
  const actor = action.actor;
  const move = action.move;
  if(!move){
    // struggle / weak punch fallback
    const dm = Math.max(1, Math.floor(actor.stats.atk / 4));
    target.curHp = Math.max(0, target.curHp - dm);
    log(`<strong>${actor.name}</strong> has no move selected and deals ${dm} damage to <strong>${target.name}</strong>.`);
    return;
  }
  // compute damage
  try{
    const res = await computeDamage(actor, target, move);
    const dmg = res.damage;
    target.curHp = Math.max(0, target.curHp - dmg);
    const effText = (res.typeEff === 0) ? 'It had no effect.' : (res.typeEff > 1 ? 'It was super effective!' : (res.typeEff < 1 ? 'It was not very effective.' : ''));
    log(`<strong>${actor.name}</strong> used <strong>${move.name}</strong> — ${dmg} damage. ${effText}`);
    if(target.curHp <= 0) log(`<strong>${target.name}</strong> fainted!`);
  }catch(err){
    console.error(err);
    log(`Error resolving move ${move.name}`);
  }
}

function concludeAfterTurn(){
  // handle fainted pokemon: if active fainted, try to switch to next non-fainted, else declare victory
  if(teamA[battle.activeA].curHp <= 0){
    const next = teamA.findIndex(p => p && p.curHp > 0);
    if(next>=0) { battle.activeA = next; log(`Team A sends out ${teamA[next].name}!`); }
    else {
      log('<strong>Team B wins the battle!</strong>');
      battle.running = false;
    }
  }
  if(teamB[battle.activeB].curHp <= 0){
    const next = teamB.findIndex(p => p && p.curHp > 0);
    if(next>=0) { battle.activeB = next; log(`Team B sends out ${teamB[next].name}!`); }
    else {
      log('<strong>Team A wins the battle!</strong>');
      battle.running = false;
    }
  }
}

// UI buttons wiring
$id('startBattle').onclick = ()=>{
  // ensure both teams have at least one pokemon
  if(!teamA.some(Boolean) || !teamB.some(Boolean)){ alert('Both teams need at least one Pokémon to start.'); return; }
  battle.running = true;
  battle.activeA = teamA.findIndex(p=>p);
  battle.activeB = teamB.findIndex(p=>p);
  log('Battle started! Active pokémon set.');
  renderActive();
};

$id('resetTeams').onclick = ()=>{
  teamA = Array(6).fill(null);
  teamB = Array(6).fill(null);
  renderTeams();
  renderActive();
  log('Teams reset.');
};

$id('resetBattle').onclick = ()=>{
  // reset HP to max for all pokes
  for(const p of teamA.filter(Boolean)) p.curHp = p.maxHp;
  for(const p of teamB.filter(Boolean)) p.curHp = p.maxHp;
  battle.selectedMoveA = null; battle.selectedMoveB = null;
  battle.running = false;
  renderActive();
  log('Battle reset (HP restored).');
};

$id('chooseMoveA').onclick = ()=>{ if(!$id('leftAuto').checked) alert('Pick a move by clicking a move button for the left side. Or toggle Auto.'); };
$id('chooseMoveB').onclick = ()=>{ if(!$id('rightAuto').checked) alert('Pick a move by clicking a move button for the right side. Or toggle Auto.'); };
$id('resolveTurn').onclick = async ()=>{
  if(!battle.running) { alert('Start the battle first.'); return; }
  await resolveTurn();
};

$id('swapSides').onclick = ()=>{
  // swap active indices between teams
  const temp = battle.activeA; battle.activeA = battle.activeB; battle.activeB = temp;
  [teamA, teamB] = [teamB, teamA]; // swap teams visually too
  log('Sides swapped.');
  renderTeams(); // re-render team slots (they are swapped)
  renderActive();
};

// initialize
renderTeams();
renderActive();
log('Ready. Build teams and press "Start battle".');

</script>
</body>
</html>
